---
title: 'yup docs 에 대한 정리'
date: '2023-04-15'
tags: ['yup']
draft: false
summary: 'yup에 대한 정리'
---

# yup 에 대한 정리

`react-hook-form` 을 사용하면서, `yup` 을 `resolver` 로 사용하고 있다.  
`yup` 을 사용하면서 기껏해야 `yup.string` 및 `yup.email`, `yup.objact` 등등...

`yup` 에서 제공하고 있는 많은 기능중, 한정적으로 사용하고 있다는 생각이 들어  내용 정리차, `blog` 에 기록해두려 한다.

## yup 이란?

다음은 `docs` 에 적혀져 있는 문구이다.
> `Yup` 은 `runtime` 에 값 분석 및 유효성검사를 하기 위한 `schema builder` 이다.

이말은, `schema` 를 작성후, 값을 평가하여, 해당 값이 정확하게 맞아 떨어지는지를 검사하고 평가한다.

이러한 평가하는 방식은, `input` 사용시 꼭 필요한 기능이다.
그러면서 다음처럼 같이 설명해준다.

> `Yup schema` 는 매우 표현력이 좋으며, 값 변환 및 의존성있는 값들의 평가 같은 복잡한 `modeling` 을 허용한다.

위의말은, 유연하게 사용할수 있는 `method` 들이 많으며, 그로인해 유효성검사를  
쉽게 할수 있다 정도로 이해하면 될것 같다.

## Schema 란?

`Schema` 는 `type` 이 디자인된 형태라고 보면된다.
`Schema` 를 통해, `input` 을 조작할 수 있다.

이러한 `Schema` 는 `method chian` 형태로, 각 기능들을 나열하여 처리 가능하다.
아래는 `Docs` 에 나와 있는 예시이다.

```ts
const num = number().cast('1'); // 1

const obj = object({
  firstName: string().lowercase().trim(),
})
  .json()
  .camelCase()
  .cast('{"first_name": "jAnE "}'); // { firstName: 'jane' }
```

위의 예시는 나열되어 있는 예시는, `json.parser` 를  
진행하고, `object` 를 `cacmelCase` 로 만들라고 하는 명령이다.

`cast` 는 어떠한 값을 넣으면, 위의 나열된 `method chain` 으로 변환해주는  
함수라고 생각하면 된다.

실제로 위의 값으로 `JSON` 객체를 넣었는데, 결과값으로, `Object` 를 반환하는것을 볼 수 있다.

`Yup` 은 이렇게 `input` 사용시 발생할 수 있는 문제들을 해결하기 위해 여러 `method` 들을 제공하며, `typescript` 역시 지원해 편리한 사용이 가능하다.

`docs` 에서는 `custom transrom`  을 만들어 처리도 가능하다고 말한다.

```ts
const reversedString = string()
  .transform((currentValue) => currentValue.split('').reverse().join(''))
  .cast('dlrow olleh'); // "hello world"
```

여기서, `transform` 을 사용해 안쪽에 함수를 전달해주면, `Yup` 에서  
직접 만든 `method` 를 사용하여 조작 가능하다.

다른 예시도 많으므로, [Docs](https://www.npmjs.com/package/yup#objectcamelcase-schema) 에서 살펴보는것이 좋을듯 싶다.

## Typescript integration

`Yup` 은 정적 `Typescript interface` 생성이 가능하다. 다음을 보자.

```ts
import * as yup from 'yup';

const personSchema = yup.object({
  firstName: yup.string().defined(),
  nickName: yup.string().default('').nullable(),
  sex: yup
    .mixed()
    .oneOf(['male', 'female', 'other'] as const)
    .defined(),
  email: yup.string().nullable().email(),
  birthDate: yup.date().nullable().min(new Date(1900, 0, 1)),
});

interface Person extends yup.InferType<typeof personSchema> {
  // using interface instead of type generally gives nicer editor feedback
}
```

`interface Person` 에 `yup.InferType` 을 사용하여, `type` 을 추론한후 확장하여 지정한다.

또한 `Schema` 에 `default` 값을 줄수 있다고도 되어있다.

```ts
import { string } from 'yup';

const value: string = string().default('hi').validate(undefined);

// vs

const value: string | undefined = string().validate(undefined);
```

`Yup` 은 `typescript` 를 지원한다고 했으므로, 역시나 `interface` 를 지정하여, 해당 `interface` 를 `yup` 에 넘겨 처리할 수 도 있다.

```ts
import { object, number, string, ObjectSchema } from 'yup';

interface Person {
  name: string;
  age?: number;
  sex: 'male' | 'female' | 'other' | null;
}

// will raise a compile-time type error if the schema does not produce a valid Person
const schema: ObjectSchema<Person> = object({
  name: string().defined(),
  age: number().optional(),
  sex: string<'male' | 'female' | 'other'>().nullable().defined();
});

// ❌ errors:
// "Type 'number | undefined' is not assignable to type 'string'."
const badSchema: ObjectSchema<Person> = object({
  name: number(),
});
```

### API

`API` 는 다음의 `module` 형식을 따른다고 한다.

```ts
// core schema
import {
  mixed,
  string,
  number,
  boolean,
  bool,
  date,
  object,
  array,
  ref,
  lazy,
} from 'yup';

// Classes
import {
  Schema,
  MixedSchema,
  StringSchema,
  NumberSchema,
  BooleanSchema,
  DateSchema,
  ArraySchema,
  ObjectSchema,
} from 'yup';

// Types
import type { InferType, ISchema, AnySchema, AnyObjectSchema } from 'yup';
```

### reach

`reach` 는 `nested schemas` 중에 제공된 `path` 를 기반으로, 그 값을 찾는다.

```ts
import { reach } from 'yup';

let schema = object({
  nested: object({
    arr: array(object({ num: number().max(4) })),
  }),
});

reach(schema, 'nested.arr.num');
reach(schema, 'nested.arr[].num');
reach(schema, 'nested.arr[1].num');
reach(schema, 'nested["arr"][1].num');
```

### ref

`ref` 는 필드의 자속 혹은 형제를 참조하는 `field` 를 만들 수 있다.  
아래를 보도록 하자.


```ts
import { ref, object, string } from 'yup';

let schema = object({
  baz: ref('foo.bar'),
  foo: object({
    bar: string(),
  }),
  x: ref('$x'),
});

schema.cast({ foo: { bar: 'boom' } }, { context: { x: 5 } });
// => { baz: 'boom',  x: 5, foo: { bar: 'boom' } }
```

위의 예를 보면, `baz` 는 `ref` 를 통해, 자신의 형제 필드의 자손인 `foo.bar` 의 값을 참조하는것을 볼 수 있다.

여기서, `$x` 의 의미가 중요한다, `Yup` 에서는 `$` 기호를 이용하여, 컨텍스트의 값을 참조 할 수 있다.

위의 예시를 보면, `{ context: { x: 5 } }` 를 통해, 추가정보를를 전달하기 위해 `context` 에 `x` 값을 넣었고, `schema` 에서는 `context` 의 `x` 를 사용하기 위해 `$` 를 사용하여 참조하고 있다.

---

#### context

`schema` 검증시 추가 정보를 전달하기 위한 객체이다.  
`context` 는 `schema` 검증시, 검증 함수에 전달되고, 해당 검증 함수에서
`"$"` 를 사용해서 `context` 의 `field` 를 참조한다.

`context` 는 다음의 `proerties` 로 이루어져 있다.

> "value", "path", "label

---

`ref` 의 중요한 부분중 하나는, 자기 자신의 `field` 를 참조할 수 있다는 것이다.  

이러한 부분은 `circuler dependencies`  가 발생할 수 있으니, 조심스럽게 사용해야 한다.

### lazy

> 유효성 검사 / 캐스트 시간에 평가되는 스키마

`Docs` 에서는 이렇게 말하고 있다.  
이는 나중에 평가되는 `schema` 라고 해서 `lazy` 라고 명명되어진것 같다.

이 `method` 는 `polymorphic(다형성)` 및 `array` 같은 `Tree` 를 가진 `Schema` 에서 재귀적으로 생성하는데 유용하다고 되어 있다.

> 사실 그렇게까지는 와닿지는 않은 방식이라, 써보면서 익혀야 될것 같다.

```ts
let node = object({
  id: number(),
  child: yup.lazy(() => node.default(undefined)),
});

let renderable = yup.lazy((value) => {
  switch (typeof value) {
    case 'number':
      return number();
    case 'string':
      return string();
    default:
      return mixed();
  }
});

let renderables = array().of(renderable);
```

## ValidationError

이름을 보면 알겠지만, 유효성 검사 오류를 지정해주는 함수이다.
유효성 검사가 실패했을때 `error` 를 던진다.
`Docs` 에서는 다음처럼 이루어져 있다고 한다.

- name: "ValidationError" 
- type: 실패된 `test이름` 또는 `type` 을 지정한다.
- value: 테스트된 `field` 의 `value` 값이다.
- params ?: `test inpu` 들이다,  에를 들어, `max value`, `regex` 같은...
- errors: `error message` 들의 배열이다.
- inner: `집계 오류인 경우`, 유효성 검사 `chain` 초기에 발생하는, `ValidataionErrors` 의 배열이다. <br/>`abortEarly` 옵션이 `false`일때, 발생한 각 오류를 검사할 수 있다. 이 오류에는 각 내부 오류의 모든 메시지가 포함된다.

## Schema

`schema`는 `bastract base class(추상 기반 class)` 이다.  
`schema` 는 `schema type` 에 기본 `methods` 및 `properties` 를 제공한다.

### Schema.clone(): Schema

`Schema` 를 `deep copy` 한다.
`Schema` 복제는 상태 변경과 함께 새 스키마를 반환하기 위해 내부적으로 사용된다고 한다

### Schema.label(label: string): Schema

`error message` 안의 사용된 `key name` 을 `overrinding` 한다.

### Schema.meta(metadata: object): Schema

`metadata` 객체를 추가한다
`schema` 와 함께 `data` 를 저장할때 유용하다
`cast` 객체 자신에게 포함되지 않는, `data` 를 저장할때 유용하다

### Schema.describe(options?: ResolveOptions): SchemaDescription

직렬화된 `description` 객체안의 `schema` 의 세부정보 모음이다.
> (like meta, labels, active tests)

`Docs` 에서의 예제는 다음과 같다

```ts
const schema = object({
  name: string().required(),
});

const description = schema.describe();
```

이렇게 하면 `description` 변수에는 `schema` 에 설정한 세부정보를 담은  
객체를 가진다.

하지만, `dynamic component` 같은 경우는, 정확한 `schema` 설명을 리턴하기 위한 더 많은 `context` 를 서술해야 한다.

```ts
import { ref, object, string, boolean } from 'yup';

let schema = object({
  isBig: boolean(),
  count: number().when('isBig', {
    is: true,
    then: (schema) => schema.min(5),
    otherwise: (schema) => schema.min(0),
  }),
});

schema.describe({ value: { isBig: true } });
```

위의 `when()` 은 `isBig` 의 값이 `true` 이면, `count` 는 `min` 값은 `5` 이고, 아니면 `0` 이다. 로 해석된다.

이렇게 `describe` 함수를 하용할때, 값이 `dynamic` 하게 변경되는 값이면,  
`context` 를 작성하여, 처리해주어야 한다고 서술되어 있다.

> 해당 부분의 `docs` 를 보면서 개념적이해를 하고 있는 상황이라 실제로 써보면서 조금더 살펴보아야 할것 같다.

`Docs` 에서는 아래의 코드를 부여주면서 `description types` 라고 한다.
참고로, `schema type` 에 의존하여 약간씩 달라질 수 있다고 한다.

```ts
interface SchemaDescription {
  type: string;
  label?: string;
  meta: object | undefined;
  oneOf: unknown[];
  notOneOf: unknown[];
  default?: unknown;
  nullable: boolean;
  optional: boolean;
  tests: Array<{ name?: string; params: ExtraParams | undefined }>;

  // Present on object schema descriptions
  fields: Record<string, SchemaFieldDescription>;

  // Present on array schema descriptions
  innerType?: SchemaFieldDescription;
}

type SchemaFieldDescription =
  | SchemaDescription
  | SchemaRefDescription
  | SchemaLazyDescription;

interface SchemaRefDescription {
  type: 'ref';
  key: string;
}

interface SchemaLazyDescription {
  type: string;
  label?: string;
  meta: object | undefined;
}
```

어허,, 이부분은 추후 더 살펴보아야 할것 같다..

### Schema.concat(schema: Schema): Schema

2개의 schema 를 결합하여 새로운 `schema` 를 만든다
동일한 유형의 `schema` 만 `concatenated` 한다 

`concat` 은 `schema` 를 재정의한다는 것에서 `merge` 기능이 아니라고 말한다.

```ts

import * as Yup from 'yup';

const schema1 = Yup.object().shape({
  name: Yup.string().required(),
  age: Yup.number().integer().min(18).max(99),
});

const schema2 = Yup.object().shape({
  email: Yup.string().email().required(),
  password: Yup.string().matches(/^[a-zA-Z0-9]{3,30}$/),
});

const mergedSchema = schema1.concat(schema2);

```

### Schema.validate(value: any, options?: object): Promise<InferType<Schema>, ValidationError>

`input value` 의 유효성을 평가하고 리턴한다.
리턴될 값은 평가된 값 혹은 `throwing error` 이다.

이 `method` 는 비동기적이고, `promise object` 를 반환한다.
이 `promise object` 는 `value` 와 함께 이행(`fullfilled`) 되거나,`ValidationError` 와 함께 거부(`reject`) 된다.

```ts

value = await schema.validate({ name: 'jimmy', age: 24 })

```

`options` 는 좀더 구체적으로 조작하기위해 제공한다.

```ts
interface Options {
  // when true, parsing is skipped an the input is validated "as-is"
  strict: boolean = false;
  // Throw on the first error or collect and return all
  abortEarly: boolean = true;
  // Remove unspecified keys from objects
  stripUnknown: boolean = false;
  // when `false` validations will be performed shallowly
  recursive: boolean = true;
  // External values that can be provided to validations and conditionals
  context?: object;
}
```

위의 제공되는 `Options` 를 제공한다.

### Schma.validateSync(value: any, options?: object): InferType<Scehma>

동기적으로 `validations` 를 실행한다.
이는 결과를 반환하거나, `ValidationError` 를 `throw` 한다

`options` 는 위의 `validate` 와 동일하다

동기적 `validation`  은 `aync test` 가 없는 경우에만 작동한다.  
예를들어 `Promise` 를 반환하는 `test` 같은경우 다음과 같이 작동한다.

```ts
let schema = number().test('is-42', "this isn't the number i want", (value) =>
  Promise.resolve(value != 42),
);

schema.validateSync(42); // throws Error
```

다음은 `Promise` 를 반환하지 않는 `test` 이다.

```ts
let schema = number().test(
  'is-42',
  "this isn't the number i want",
  (value) => value != 42,
);

schema.validateSync(23); // throws ValidationError
```

### Schema.validateAt(path: string, value: any, options?: object): Promise<InferType<Schema>, ValidationError>

중첩된 경로를 통해 검증하지만, 결과 `schema` 를 유효성 대상으로 사용한다.

```ts

let schema = object({
  foo: array().of(
    object({
      loose: boolean(),
      bar: string().when('loose', {
        is: true,
        otherwise: (schema) => schema.strict(),
      }),
    }),
  ),
});

let rootValue = {
  foo: [{ bar: 1 }, { bar: 1, loose: true }],
};

await schema.validateAt('foo[0].bar', rootValue); // => ValidationError: must be a string

await schema.validateAt('foo[1].bar', rootValue); // => '1'

```

### Schema.validateSyncAt(path: string, value: any, options?: object): InferType<Schema>

이는 `validateAt` 의 동기적 버전이다.

### Schema.isValid(value: any, options?: object): Promise<boolean>

주어진 `value` 가 `schema` 와 일치하면 `true` 를 리턴한다.
`isValid` 는 `asunchronous` 이므로, `promise` 객체를 반환한다.

### Schema.isValidSync(value: any, options?: object): boolean

`isValid` 의 `동기적` 버전이다.

### Schema.cast(value: any, options = {}): InferType<Schema>

주어진 `value` 와 `Schema` 와 강제로 일치하기 위해 시도한다.
예를 들어, `number()` 타입을 사용할때 `'5'` 는 `5` 로 변환한다.  

`cast` 가 실패되면 일반적으로 `null` 을 반환한다. 그러나, 유효하지않은 `string` 이라면 `NaN` 같은 결과를 리턴할수도 있다.

설정할 수 있는 값들 역시 같이 제공한다.

```ts

interface CastOptions<TContext extends {}> {
  // Remove undefined properties from objects
  stripUnknown: boolean = false;

  // Throws a TypeError if casting doesn't produce a valid type
  // note that the TS return type is inaccurate when this is `false`, use with caution
  assert?: boolean = true;

  // External values that used to resolve conditions and references
  context?: TContext;
}

```

### Schema.isType(value: any): value is InferType<Schema>

전달된 `value` 에 대해서 `type check` 를 한다.
일치한다면 `true`를 반환하며, `value` 를 `cast` 하지는 않는다.

모든 `Schema` 타입을 체크하는데 `isType` 을 사용해야한다.

### Schema.strip(enabled: boolean = true): Schema

출력 `object` 에서 제거할  `schema` 를 표시한다. 
오직, 중첩된 `schema` 에서 작동한다.

```ts

let schema = object({
  useThis: number(),
  notThis: string().strip(),
});

schema.cast({ notThis: 'foo', useThis: 4 }); // => { useThis: 4 }

```

`Docs` 에서는 `strip` 이 적용된 `schema` 는 타입이 `naver` 으로 추론되므로,  모든 유형에서 제거된다고 한다.

```ts

let schema = object({
  useThis: number(),
  notThis: string().strip(),
});

InferType<typeof schema>; /*
{
   useThis?: number | undefined
}
*/

```

### Schema.default(value: any): Schema

`value` 가 `undefined` 일때, `default value` 를 설정한다.  
`default` 는 변형이 실행된 이후에 생성된다.  
이는 유효성검사 이전에 지정된 안전한 `default` 를 보장하는데 도움이 된다.

이 `default value` 는 사용될때마다, `cloned` 되어, `object` 및 `array` 사용시 크기가 클 경우 성능 저하가 발생될수 있다.

이 `overhead` 를 방지하기 위해 새로운 `default` 를 반환하는 `function` 을 통해 값을 전달하는 방식도 존재한다.

그 값이 크지 않다면 기본값으로 설정해도 되지만, 객체의 크기가 클경우에는 `function` 으로 대체해서 처리하는것이 좋을듯 싶다

`default` 속성은 `null` 도 비어있는 값으로 간주한다.
그래서, 해당 필드가 누락된다면 `null` 이 아니라 `""` 로 설정한다.

```ts
yup.string.default('nothing');

yup.object.default({ number: 5 }); // object will be cloned every time a default is needed

yup.object.default(() => ({ number: 5 })); // this is cheaper

yup.date.default(() => new Date()); // also helpful for defaults that change over time
```

### Schema.getDefault(options?: object): Any

`default value` 를 설정한 값을 찾는데 사용된다.

### Schema.nullable(): Schema

`null` 을 가리킨다.
`nullable()` 없으면 `null` 은 다른유형으로 취급된다.
`Schema.isType` 으로 `check` 할때 실패할것이다. 

```ts
const schema = number().nullable();

schema.cast(null); // null

InferType<typeof schema>; // number | null
```

### Schema.nonNullable(): Schema

`nullable()` 과 반대된다. `Schema` 를 에서 유효한 유형의 값들로 부터 `null` 을 제거한다

`Schma` 는 기본적으로 `null` 을 허용하지 않는다

```ts
const schema = number().nonNullable();

schema.cast(null); // TypeError

InferType<typeof schema>; // number
```

### Schema.defined(): Schema

`Schema` 에 대한 `value`을 반드시 정의해야 한다
모든 `field` 값들은 `undefined` 외의 모든 값은 이 요구사항에 충족한다.

이 말은 값은 반드시 지정되어야 하지만, `null` 값은 허용됨을 말한다.

```ts
const schema = string().defined();

schema.cast(undefined); // TypeError

InferType<typeof schema>; // string
```

### Schema.optional(): Schema

`defined()` 의 반대이다.
제공되는 타입의 `value` 는 `undefined` 를 허용한다

```ts
const schema = string().optional();

schema.cast(undefined); // undefined

InferType<typeof schema>; // string | undefined
```

### Schema.required(message?: string | function): Schema

`Schema` 에 `required` 를 표시한다면, 값으로써 `null`, `undefined` 를 허용하지 않는다.

이는 `defeind` 와는 다르다.
`defined` 는 `null` 을 허용하지만, `undefined` 는 허용하지 않는다. 

그러므로, `required` 는  `optional` 과 `nallable` 의 반대되는 `method` 이다. 

> `Docs` 에서 `string().required` 일때, `null`, `undefined` 뿐만 아니라 `""` 빈 문자열도 허용하지 않으므로, 주의하라고 설명해준다.

### Schema.notRequired(): Schema

`notRequired()` 를 표시하면, `schema.nullable().optional()` 처럼 동작한다.

### Schema.typeError(message: string): Schema

`type check` 가 실패될때, `error message` 를 정의한다.
`${value}` 그리고 `${type}` 은 `message` 인자 안에서 사용할 수 있다.

### Schema.oneOf(arrayOfValues: Array<any>, message?: string | function): Schema Alias: equals

오직, 값 집합의 값들만 허용한다.
이는 마치 배열처럼 동작하며, 해당 배열의 값을 `isValid` 함수를 통해 확인가능하다.

검증시 확인된 `resolved values` 를 `get` 할때, `${value}` 보간 및 `refs` 또는 `ref` 가 있다면, `${resolved}` 보간은 `message` 인자안에서 보간으로 사용될 수 있다.

`undefined` 는 `arrayOfValues` 에 포함되지 않는 경우에도 검증에 실패되지 않는다.

만약, `undefined` 를 원치 않는다면, `Schema.required` 를 사용할 수 있다.

```ts

let schema = yup.mixed().oneOf(['jimmy', 42]);

await schema.isValid(42); // => true
await schema.isValid('jimmy'); // => true
await schema.isValid(new Date()); // => false

```

### Schema.notOneOf(arrayOfValues: Array<any>, message?: string | function)

이는 `oneOf()` 에 반대되는 `method` 이다.
값의 집합에 있는 값은 허용하지 않는다.

```ts
let schema = yup.mixed().notOneOf(['jimmy', 42]);

await schema.isValid(42); // => false
await schema.isValid(new Date()); // => true

```

### Schema.when(keys: string | string[], builder: object | (values: any[], schema) => Schema): Schema

형제 또는 형제의 자손 `field` 를 기반으로 한 `schema` 를 조정하는데 사용된다.
마치 `case` 문처럼 처리가 가능하며, 작동은 다음과 같다

`when` 에는 `object literal` 혹은 `함수` 를 넣을 수 있다.

`object` 에 `is` 라는 `key` 에는 `value` 또는 `matcher function` 을 제공한다.
이로써, `key` 에서 제공되는 값과 형제 및 형제의 자손 `field` 와 같아면, `then` 이 실행되고, 그렇지 않다면 `otherwise` 가 실행된다.

또한, `is` 는 `(엄격한 동등 연산자)===` 로 작동하며, 다른 방식을 원한다면 함수를 통해 설정가능하다

> 예) is: (value) => value == true

이는 다른 `field` 에 대한 의존하여 값이 설정될때 사용된다.

`input value` 대신에 `context` 에 연관된 `property` 를 지정할때는 `$` 를 `prefix` 로 사용할 수 있다.

`context` 를 사용하고 싶다면, `validate`  및 `cast` 를 사용하여 지정해야 한다.

```ts

let schema = object({
  isBig: boolean(),
  count: number()
    .when('isBig', {
      is: true, // alternatively: (val) => val == true
      then: (schema) => schema.min(5),
      otherwise: (schema) => schema.min(0),
    })
    .when('$other', ([other], schema) =>
      other === 4 ? schema.max(6) : schema,
    ),
});

await schema.validate(value, { context: { other: 4 } }); // context 를 사용한 예

```

만약, `dependant key` 를 더 지정하고 싶다면, 배열을 사용한다.
이때, 배열안에 들어간 값은 `&&` 처럼 사용된다.

```ts
let schema = object({
  isSpecial: boolean(),
  isBig: boolean(),
  count: number().when(['isBig', 'isSpecial'], {
    is: true, // alternatively: (isBig, isSpecial) => isBig && isSpecial
    then: (schema) => schema.min(5),
    otherwise: (schema) => schema.min(0),
  }),
});

await schema.validate({
  isBig: true,
  isSpecial: true,
  count: 10,
});
```

다르게 작성도 가능한데, `function` 을 사용해서 `schema` 를 리턴한다.

```ts

let schema = yup.object({
  isBig: yup.boolean(),
  count: yup.number().when('isBig', ([isBig], schema) => {
    return isBig ? schema.min(5) : schema.min(0);
  }),
});

await schema.validate({ isBig: false, count: 4 });

```

`function` 의 첫번쩨 인자는, 제공된 `key` 에대한 값의 배열이며, 두번째 인자는 현재 `schema` 를 제공한다.

