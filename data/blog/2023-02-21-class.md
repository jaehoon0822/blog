---
title: Editor 원리 및 Next.js 의 원리
date: '2023-02-20'
tags: ['javascript', 'next.js']
draft: false
summary: 'Editor 의 원리 및 Next.js 의 원리'
---

# 결제

> 결제가 어떻게 이루어지는지의 흐름

```
[ browser ]
    |
    | <--- 브라우저에서 결제 요청
    |
[ backend server ]
    |
    | <--- 결제솔루션사에 원하는 PG사 결제 요청
    | <--- REST API(/payment, payment/cancle, etc)
    |
[ 결제솔루션사 ]: 아임포트(포트원), 부트페이, ...
    |
    | <--- 결제솔루션사에서 해당 PG사 결제요청
    |
[ PG(Payment Gateway)'s ]
    |
    | <--- 카드사에 결제요청
    |
[ Card Companies ]
```

결제가 이루어진이후 `imp_uid` 같은 `결제 ID` 를 보내준다.

받은 `response` 에는 다음과 비슷한 객체를 가질것이다.

```
{
  imp_uid: "imp_123456",
  amout: ...
  date: ....
  ...
}
```

이렇게 받은 `response` 를 사용하여 `backend` 에서 다시한번 해당 결제 정보를 `결제솔루션` 사에서 확인한 이후, `DB` 에 저장한다. 



> 승인과정
```

[ 결제승인 ]
    ^
    |
    | <-- 결제 연동 최소일정: 
    |                    PG 계약 (1주일)
    |                    카드심사(2주일)
    |                    아무리 빨라도 3주일 필요
    |
    v
[ PG 사 ]
    ^
    |
    | <-- <카드사심사>
    | <-- 결제 실패 요인: 도박, 경매, 결제금액 직접 입력 안됨... 등등... 
    | 
    v
[ 카드사 ]

```

# PORTONE
> 결제솔루션사

[PORTONE](https://portone.gitbook.io/docs/api/api-9/api) 에서 원하는 API 를 사용하여 구현 가능하다.

# Javascript 

### new Date 의 의험성

> `client` 에서 `new Date()` 로 사용하는것은 신뢰하기 힘들다.
>
> `new Date` 는 컴퓨터에 사용되는 시간에 의존한다.
> 시간은 `Backend` 에서 요청받은 시간을 사용하는것이 좋다.
>
> 가급적, 시간 관련해서 `new Date` 를 사용하지 않는 것이 좋다.


### 시차(UTC)
> UTC 는 세계표준시간 이다.
>
> UTC 시간으로 계산한후 `DB` 에 저장한다.

`UTC` 시간으로 `DB` 에 저장한후, 시간이 다른 `한국` 이 아닌 `미국`  으로 `data` 를 보낸다고 가정하자.

 `UTC` 에서 `미국의 시차만큼 차감` 해 주면, `미국` 현지 시간에 맞추어 `data` 전송이 가능하다.

> 하지만 이러한 과정은 불편하다.
>
> 이러한 과정을 쉽게 해결해주는 `libray` 가 있다.
> . 
<br/>
<br/>[moment.js](https://www.npmjs.com/package/moment)

### Event trigger 시키는법

이벤트 발생시킬시 보통 2가지 상황이 발생한다.
1. 사용자의 행동 (click, typing)
2. 특정 시간에 도달 --> crontab 사용

## 싱글스레드 VS 멀티스레드

> 프로세스 ==> 프로그램
> 스레드 ==> 프로그램 내에서 일하는 일꾼
> CPU ==> 실제 처리되는 곳

스레드가 많다고 해도 실제 처리 되는곳은 CPU 이다.
그러므로, 스레드는 일을 분담해서 나눌뿐, 처리 되는 곳은 `CPU` 이므로 멀티스레드라고 해서 빠르지는 않다.

* ***멀티스레드 처리방식***<br/>
하나의 일을 각 `thread` 가 조금씩 조금씩 여러개를 처리하는것 처럼 보일수 있다. 이른 `context switcing` 이라 한다

* ***싱글스레드 처리방식***<br/>
모든 일을 하나하나씩 각계격파하듯 처리한다.

그렇다고 `Single thread` 가 좋지만은 않다.
`Single thread` 는 하나씩 일을 처리 하므로, 오래걸리는 작업이 있다면, 오래걸리는 시간 만큼 기다린다.

하지만 `Multi thread` 는 오래걸리는 작업이 있더라도 다른 작업을 같이 조금조금씩 여러개를 처리하므로, 마치 동시에 처리되는것 처럼 보여준다. 즉 오래 걸리는 작업이 있다고 하더라도, 여러 작업을 분할해서 처리하기에 멈춤없이 사용한다.


